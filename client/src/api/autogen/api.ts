/* tslint:disable */
/* eslint-disable */
/**
 * Amazon Clone API
 * v1
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface CartItem
 */
export interface CartItem {
  /**
   *
   * @type {string}
   * @memberof CartItem
   */
  _id: string;
  /**
   *
   * @type {number}
   * @memberof CartItem
   */
  __v?: number;
  /**
   *
   * @type {string}
   * @memberof CartItem
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CartItem
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof CartItem
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof CartItem
   */
  quantity: number;
}
/**
 *
 * @export
 * @interface CheckoutCartDto
 */
export interface CheckoutCartDto {
  /**
   *
   * @type {Array<CartItem>}
   * @memberof CheckoutCartDto
   */
  cart: Array<CartItem>;
}
/**
 *
 * @export
 * @interface CheckoutCartVo
 */
export interface CheckoutCartVo {
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  object: string;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  amount: number;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  amount_capturable: number;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  amount_received: number;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  application?: string;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  application_fee_amount?: number;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  automatic_payment_methods?: string;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  canceled_at?: number;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  cancellation_reason?: string;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  capture_method: string;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  client_secret: string;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVo
   */
  confirmation_method: string;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVo
   */
  created: number;
}
/**
 *
 * @export
 * @interface CheckoutCartVoUnifiedRes
 */
export interface CheckoutCartVoUnifiedRes {
  /**
   *
   * @type {CheckoutCartVo}
   * @memberof CheckoutCartVoUnifiedRes
   */
  data?: CheckoutCartVo;
  /**
   *
   * @type {number}
   * @memberof CheckoutCartVoUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof CheckoutCartVoUnifiedRes
   */
  error_msg?: string;
}
/**
 *
 * @export
 * @interface CreateProductDto
 */
export interface CreateProductDto {
  /**
   *
   * @type {string}
   * @memberof CreateProductDto
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CreateProductDto
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof CreateProductDto
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ExistingUserDTO
 */
export interface ExistingUserDTO {
  /**
   *
   * @type {string}
   * @memberof ExistingUserDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ExistingUserDTO
   */
  password: string;
}
/**
 *
 * @export
 * @interface GetAllProductsVo
 */
export interface GetAllProductsVo {
  /**
   *
   * @type {Array<ProductItem>}
   * @memberof GetAllProductsVo
   */
  products?: Array<ProductItem>;
}
/**
 *
 * @export
 * @interface GetAllProductsVoUnifiedRes
 */
export interface GetAllProductsVoUnifiedRes {
  /**
   *
   * @type {GetAllProductsVo}
   * @memberof GetAllProductsVoUnifiedRes
   */
  data?: GetAllProductsVo;
  /**
   *
   * @type {number}
   * @memberof GetAllProductsVoUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof GetAllProductsVoUnifiedRes
   */
  error_msg?: string;
}
/**
 *
 * @export
 * @interface GetProductVo
 */
export interface GetProductVo {
  /**
   *
   * @type {ProductItem}
   * @memberof GetProductVo
   */
  product?: ProductItem;
}
/**
 *
 * @export
 * @interface GetProductVoUnifiedRes
 */
export interface GetProductVoUnifiedRes {
  /**
   *
   * @type {GetProductVo}
   * @memberof GetProductVoUnifiedRes
   */
  data?: GetProductVo;
  /**
   *
   * @type {number}
   * @memberof GetProductVoUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof GetProductVoUnifiedRes
   */
  error_msg?: string;
}
/**
 *
 * @export
 * @interface LoginVo
 */
export interface LoginVo {
  /**
   *
   * @type {string}
   * @memberof LoginVo
   */
  token: string;
}
/**
 *
 * @export
 * @interface LoginVoUnifiedRes
 */
export interface LoginVoUnifiedRes {
  /**
   *
   * @type {LoginVo}
   * @memberof LoginVoUnifiedRes
   */
  data?: LoginVo;
  /**
   *
   * @type {number}
   * @memberof LoginVoUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof LoginVoUnifiedRes
   */
  error_msg?: string;
}
/**
 *
 * @export
 * @interface NewUserDTO
 */
export interface NewUserDTO {
  /**
   *
   * @type {string}
   * @memberof NewUserDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof NewUserDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof NewUserDTO
   */
  password: string;
}
/**
 *
 * @export
 * @interface ProductItem
 */
export interface ProductItem {
  /**
   *
   * @type {string}
   * @memberof ProductItem
   */
  _id: string;
  /**
   *
   * @type {number}
   * @memberof ProductItem
   */
  __v?: number;
  /**
   *
   * @type {string}
   * @memberof ProductItem
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ProductItem
   */
  price: number;
  /**
   *
   * @type {string}
   * @memberof ProductItem
   */
  description?: string;
}
/**
 *
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
  /**
   *
   * @type {string}
   * @memberof UpdateProductDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateProductDto
   */
  price?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateProductDto
   */
  description?: string;
}
/**
 *
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  name: string;
}
/**
 *
 * @export
 * @interface UserDetailUnifiedRes
 */
export interface UserDetailUnifiedRes {
  /**
   *
   * @type {UserDetail}
   * @memberof UserDetailUnifiedRes
   */
  data?: UserDetail;
  /**
   *
   * @type {number}
   * @memberof UserDetailUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof UserDetailUnifiedRes
   */
  error_msg?: string;
}
/**
 *
 * @export
 * @interface VerifyJwtDto
 */
export interface VerifyJwtDto {
  /**
   *
   * @type {string}
   * @memberof VerifyJwtDto
   */
  jwt: string;
}
/**
 *
 * @export
 * @interface VerifyJwtVo
 */
export interface VerifyJwtVo {
  /**
   *
   * @type {number}
   * @memberof VerifyJwtVo
   */
  exp: number;
}
/**
 *
 * @export
 * @interface VerifyJwtVoUnifiedRes
 */
export interface VerifyJwtVoUnifiedRes {
  /**
   *
   * @type {VerifyJwtVo}
   * @memberof VerifyJwtVoUnifiedRes
   */
  data?: VerifyJwtVo;
  /**
   *
   * @type {number}
   * @memberof VerifyJwtVoUnifiedRes
   */
  error?: number;
  /**
   *
   * @type {string}
   * @memberof VerifyJwtVoUnifiedRes
   */
  error_msg?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ExistingUserDTO} existingUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (
      existingUserDTO: ExistingUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'existingUserDTO' is not null or undefined
      assertParamExists(
        "authControllerLogin",
        "existingUserDTO",
        existingUserDTO
      );
      const localVarPath = `/api/v1/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        existingUserDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {NewUserDTO} newUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerRegister: async (
      newUserDTO: NewUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'newUserDTO' is not null or undefined
      assertParamExists("authControllerRegister", "newUserDTO", newUserDTO);
      const localVarPath = `/api/v1/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newUserDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {VerifyJwtDto} verifyJwtDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerVerifyJwt: async (
      verifyJwtDto: VerifyJwtDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyJwtDto' is not null or undefined
      assertParamExists(
        "authControllerVerifyJwt",
        "verifyJwtDto",
        verifyJwtDto
      );
      const localVarPath = `/api/v1/auth/verify-jwt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyJwtDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ExistingUserDTO} existingUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      existingUserDTO: ExistingUserDTO,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LoginVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerLogin(
          existingUserDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {NewUserDTO} newUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerRegister(
      newUserDTO: NewUserDTO,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserDetailUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerRegister(
          newUserDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {VerifyJwtDto} verifyJwtDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerVerifyJwt(
      verifyJwtDto: VerifyJwtDto,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<VerifyJwtVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authControllerVerifyJwt(
          verifyJwtDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @param {ExistingUserDTO} existingUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(
      existingUserDTO: ExistingUserDTO,
      options?: any
    ): AxiosPromise<LoginVoUnifiedRes> {
      return localVarFp
        .authControllerLogin(existingUserDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {NewUserDTO} newUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerRegister(
      newUserDTO: NewUserDTO,
      options?: any
    ): AxiosPromise<UserDetailUnifiedRes> {
      return localVarFp
        .authControllerRegister(newUserDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {VerifyJwtDto} verifyJwtDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerVerifyJwt(
      verifyJwtDto: VerifyJwtDto,
      options?: any
    ): AxiosPromise<VerifyJwtVoUnifiedRes> {
      return localVarFp
        .authControllerVerifyJwt(verifyJwtDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @param {ExistingUserDTO} existingUserDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(existingUserDTO: ExistingUserDTO, options?: any) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(existingUserDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {NewUserDTO} newUserDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerRegister(newUserDTO: NewUserDTO, options?: any) {
    return AuthApiFp(this.configuration)
      .authControllerRegister(newUserDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {VerifyJwtDto} verifyJwtDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerVerifyJwt(verifyJwtDto: VerifyJwtDto, options?: any) {
    return AuthApiFp(this.configuration)
      .authControllerVerifyJwt(verifyJwtDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {CreateProductDto} createProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerCreateProduct: async (
      createProductDto: CreateProductDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createProductDto' is not null or undefined
      assertParamExists(
        "productControllerCreateProduct",
        "createProductDto",
        createProductDto
      );
      const localVarPath = `/api/v1/product`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProductDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerDeleteProduct: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productControllerDeleteProduct", "id", id);
      const localVarPath = `/api/v1/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerFindAllProducts: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/product`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerFindProduct: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productControllerFindProduct", "id", id);
      const localVarPath = `/api/v1/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {UpdateProductDto} updateProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerUpdateProduct: async (
      id: string,
      updateProductDto: UpdateProductDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productControllerUpdateProduct", "id", id);
      // verify required parameter 'updateProductDto' is not null or undefined
      assertParamExists(
        "productControllerUpdateProduct",
        "updateProductDto",
        updateProductDto
      );
      const localVarPath = `/api/v1/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProductDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateProductDto} createProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productControllerCreateProduct(
      createProductDto: CreateProductDto,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetProductVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productControllerCreateProduct(
          createProductDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productControllerDeleteProduct(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetProductVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productControllerDeleteProduct(
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productControllerFindAllProducts(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAllProductsVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productControllerFindAllProducts(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productControllerFindProduct(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetProductVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productControllerFindProduct(
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} id
     * @param {UpdateProductDto} updateProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productControllerUpdateProduct(
      id: string,
      updateProductDto: UpdateProductDto,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetProductVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productControllerUpdateProduct(
          id,
          updateProductDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProductApiFp(configuration);
  return {
    /**
     *
     * @param {CreateProductDto} createProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerCreateProduct(
      createProductDto: CreateProductDto,
      options?: any
    ): AxiosPromise<GetProductVoUnifiedRes> {
      return localVarFp
        .productControllerCreateProduct(createProductDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerDeleteProduct(
      id: string,
      options?: any
    ): AxiosPromise<GetProductVoUnifiedRes> {
      return localVarFp
        .productControllerDeleteProduct(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerFindAllProducts(
      options?: any
    ): AxiosPromise<GetAllProductsVoUnifiedRes> {
      return localVarFp
        .productControllerFindAllProducts(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerFindProduct(
      id: string,
      options?: any
    ): AxiosPromise<GetProductVoUnifiedRes> {
      return localVarFp
        .productControllerFindProduct(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {UpdateProductDto} updateProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productControllerUpdateProduct(
      id: string,
      updateProductDto: UpdateProductDto,
      options?: any
    ): AxiosPromise<GetProductVoUnifiedRes> {
      return localVarFp
        .productControllerUpdateProduct(id, updateProductDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
  /**
   *
   * @param {CreateProductDto} createProductDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public productControllerCreateProduct(
    createProductDto: CreateProductDto,
    options?: any
  ) {
    return ProductApiFp(this.configuration)
      .productControllerCreateProduct(createProductDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public productControllerDeleteProduct(id: string, options?: any) {
    return ProductApiFp(this.configuration)
      .productControllerDeleteProduct(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public productControllerFindAllProducts(options?: any) {
    return ProductApiFp(this.configuration)
      .productControllerFindAllProducts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public productControllerFindProduct(id: string, options?: any) {
    return ProductApiFp(this.configuration)
      .productControllerFindProduct(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {UpdateProductDto} updateProductDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public productControllerUpdateProduct(
    id: string,
    updateProductDto: UpdateProductDto,
    options?: any
  ) {
    return ProductApiFp(this.configuration)
      .productControllerUpdateProduct(id, updateProductDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {CheckoutCartDto} checkoutCartDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stripeControllerCheckout: async (
      checkoutCartDto: CheckoutCartDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'checkoutCartDto' is not null or undefined
      assertParamExists(
        "stripeControllerCheckout",
        "checkoutCartDto",
        checkoutCartDto
      );
      const localVarPath = `/api/v1/stripe`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkoutCartDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CheckoutCartDto} checkoutCartDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stripeControllerCheckout(
      checkoutCartDto: CheckoutCartDto,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CheckoutCartVoUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stripeControllerCheckout(
          checkoutCartDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StripeApiFp(configuration);
  return {
    /**
     *
     * @param {CheckoutCartDto} checkoutCartDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stripeControllerCheckout(
      checkoutCartDto: CheckoutCartDto,
      options?: any
    ): AxiosPromise<CheckoutCartVoUnifiedRes> {
      return localVarFp
        .stripeControllerCheckout(checkoutCartDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
  /**
   *
   * @param {CheckoutCartDto} checkoutCartDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StripeApi
   */
  public stripeControllerCheckout(
    checkoutCartDto: CheckoutCartDto,
    options?: any
  ) {
    return StripeApiFp(this.configuration)
      .stripeControllerCheckout(checkoutCartDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetUser: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("userControllerGetUser", "id", id);
      const localVarPath = `/api/v1/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetUser(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserDetailUnifiedRes>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerGetUser(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetUser(
      id: string,
      options?: any
    ): AxiosPromise<UserDetailUnifiedRes> {
      return localVarFp
        .userControllerGetUser(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerGetUser(id: string, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerGetUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
